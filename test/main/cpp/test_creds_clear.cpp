/**
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2019 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "test_creds.h"
#include "test_ctx.h"
#include "sec_security_utils.h"
#include <memory>
#include  <openssl/pem.h>
#include  <openssl/err.h>

unsigned char sym128_a_bin[] = { 0x05, 0xe8, 0x38, 0x84, 0xc4, 0x0c, 0x0a, 0xd8,
		0x20, 0x79, 0x9e, 0xb5, 0x81, 0xf8, 0x74, 0x28 };
unsigned int sym128_a_bin_len = 16;

unsigned char sym160_a_bin[] = { 0xaa, 0xbe, 0xf6, 0x0b, 0x97, 0x3a, 0x55, 0xc0,
		0x3d, 0xa0, 0xdd, 0x85, 0xef, 0xb3, 0xbd, 0xc0, 0x2f, 0x09, 0x32, 0x88 };
unsigned int sym160_a_bin_len = 20;

unsigned char sym256_a_bin[] = { 0x6f, 0x08, 0x2b, 0xb5, 0xa9, 0xb9, 0x27, 0x3b,
		0xd5, 0x4b, 0xaf, 0xfb, 0xe9, 0x63, 0xc7, 0xd2, 0xad, 0xde, 0xf1, 0x68,
		0x87, 0x07, 0xdb, 0xc5, 0xbf, 0x7c, 0x2b, 0x33, 0x5f, 0x29, 0x99, 0x44 };
unsigned int sym256_a_bin_len = 32;

unsigned char rsa1024_der[] = { 0x30, 0x82, 0x02, 0x5d, 0x02, 0x01, 0x00, 0x02,
		0x81, 0x81, 0x00, 0xc4, 0x32, 0x70, 0x15, 0xb3, 0x53, 0xd5, 0xaf, 0x26,
		0xc2, 0xcd, 0x6e, 0x87, 0x9f, 0x13, 0x10, 0x9e, 0x3d, 0x8d, 0x6c, 0xb4,
		0x1e, 0xc8, 0xbb, 0xf1, 0xbf, 0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f,
		0x83, 0xd8, 0xe3, 0xf7, 0xe8, 0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49,
		0x6d, 0x38, 0x1d, 0x12, 0x74, 0xba, 0x9c, 0xb4, 0x38, 0x61, 0x6b, 0x44,
		0x1d, 0xac, 0xf7, 0xa7, 0x7d, 0x8a, 0x80, 0x9f, 0x56, 0x67, 0xb2, 0xe5,
		0x45, 0xbc, 0x0d, 0xde, 0xde, 0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2,
		0xf9, 0xfa, 0xe4, 0x3b, 0xa6, 0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68,
		0x85, 0x3c, 0x1b, 0x92, 0xe1, 0x6c, 0x42, 0x37, 0xe3, 0x1b, 0x7c, 0x7a,
		0x25, 0x91, 0x30, 0xd5, 0xa5, 0xf3, 0xbb, 0x91, 0x23, 0xdf, 0x23, 0x94,
		0xb8, 0xf2, 0x61, 0x4f, 0xba, 0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02,
		0x03, 0x01, 0x00, 0x01, 0x02, 0x81, 0x81, 0x00, 0x8c, 0x8d, 0xad, 0xaa,
		0x7e, 0x2b, 0xe2, 0xfb, 0x75, 0x83, 0x3c, 0xf4, 0xa0, 0x08, 0x1f, 0xfa,
		0x59, 0xc2, 0xb2, 0xdc, 0x5b, 0x35, 0x6a, 0x8c, 0xea, 0x25, 0x48, 0xe5,
		0x73, 0xb7, 0xb7, 0x4b, 0x07, 0x48, 0xc7, 0x4a, 0x99, 0xc1, 0x79, 0xcb,
		0x6d, 0x80, 0x43, 0x01, 0xb4, 0xec, 0x9f, 0xb4, 0x84, 0x12, 0x47, 0xd6,
		0x17, 0x6e, 0x04, 0xac, 0x79, 0xc1, 0xe0, 0xb6, 0x12, 0xb1, 0x67, 0x54,
		0x77, 0xa2, 0xd4, 0x80, 0xf2, 0x87, 0xb9, 0x56, 0xcc, 0xde, 0xc2, 0x52,
		0x09, 0x2d, 0x5b, 0x7b, 0x0e, 0xfa, 0xe2, 0xd8, 0x9e, 0x41, 0xaf, 0xfc,
		0x42, 0x0d, 0x24, 0x6c, 0xe2, 0x8b, 0x3a, 0xae, 0x5c, 0x17, 0x11, 0xbb,
		0x33, 0x13, 0xb8, 0x66, 0xd6, 0xc6, 0xb1, 0x2f, 0xef, 0xf0, 0x68, 0x0e,
		0x2c, 0xf9, 0x41, 0xd2, 0x7f, 0xe0, 0x15, 0xe2, 0x33, 0xf5, 0xd8, 0xb6,
		0x01, 0xb0, 0x64, 0x91, 0x02, 0x41, 0x00, 0xf3, 0x37, 0x23, 0xf9, 0xff,
		0x24, 0x37, 0x63, 0x10, 0x19, 0x6f, 0x6c, 0x35, 0xa0, 0x41, 0x3c, 0x2c,
		0x00, 0xa8, 0x71, 0xa9, 0x09, 0x0e, 0x1f, 0xc7, 0x87, 0x6e, 0x67, 0xf3,
		0x8a, 0x76, 0x5f, 0xfb, 0x69, 0x44, 0x22, 0x88, 0x36, 0x1d, 0x31, 0xb9,
		0x79, 0xd3, 0x8c, 0x92, 0xb4, 0x0c, 0x0b, 0x72, 0xdd, 0x62, 0x47, 0x86,
		0xd7, 0x7d, 0x63, 0xb1, 0xe3, 0x30, 0xb4, 0x8f, 0x89, 0x63, 0x3b, 0x02,
		0x41, 0x00, 0xce, 0x82, 0x96, 0xa8, 0x5c, 0x6a, 0x8a, 0x50, 0x31, 0xf1,
		0x9c, 0xe3, 0xaa, 0x0d, 0x89, 0xe4, 0xe2, 0x68, 0xe2, 0x25, 0xf7, 0xec,
		0x5e, 0xe8, 0xde, 0x68, 0x29, 0x84, 0xf2, 0x58, 0x68, 0xa8, 0xb3, 0x1b,
		0x36, 0x68, 0x7c, 0x2d, 0x21, 0xea, 0x92, 0xb5, 0x3a, 0x80, 0xc2, 0x45,
		0xbb, 0xc4, 0xfc, 0x38, 0xb0, 0x33, 0xe2, 0xf1, 0x93, 0x83, 0x48, 0x5d,
		0x91, 0x31, 0xc4, 0x55, 0x65, 0xbd, 0x02, 0x40, 0x0e, 0x66, 0x2d, 0x53,
		0x17, 0xaf, 0xe5, 0x37, 0x90, 0x34, 0x71, 0x4c, 0x4e, 0xc0, 0x76, 0x1c,
		0x41, 0xde, 0xa8, 0x1a, 0x52, 0x8f, 0x9e, 0xae, 0x72, 0xf9, 0xa9, 0xa7,
		0xad, 0xdb, 0x7c, 0xb6, 0xa2, 0x03, 0xd1, 0x6c, 0xd9, 0xf3, 0x9a, 0x36,
		0xdf, 0x6c, 0x3f, 0x02, 0x0b, 0x8d, 0x6d, 0x49, 0x20, 0x3b, 0xcb, 0x1d,
		0xc0, 0xf5, 0xf1, 0x0e, 0x7d, 0xf1, 0x9d, 0x68, 0x93, 0x36, 0xe7, 0x11,
		0x02, 0x40, 0x4c, 0x12, 0x93, 0x09, 0x26, 0x32, 0x21, 0x0d, 0x75, 0xb8,
		0x79, 0x80, 0xec, 0x4d, 0xdc, 0x74, 0x32, 0x6b, 0x4c, 0x93, 0x8c, 0x06,
		0xc8, 0xd7, 0xa3, 0xc6, 0x5f, 0x35, 0x18, 0x49, 0x35, 0x14, 0xa0, 0x15,
		0xf0, 0x2f, 0x01, 0x3f, 0x66, 0xf5, 0x10, 0x62, 0x2e, 0x50, 0xec, 0x3f,
		0xdf, 0xf1, 0xaa, 0xaf, 0xff, 0x48, 0xbd, 0xdb, 0x1b, 0xea, 0x0a, 0xa8,
		0x5d, 0x2a, 0x26, 0x17, 0x07, 0x49, 0x02, 0x41, 0x00, 0xb6, 0xc4, 0x4b,
		0x68, 0x82, 0xe8, 0x40, 0xc0, 0x70, 0x58, 0xdb, 0x68, 0x49, 0x30, 0x7d,
		0x6a, 0xf1, 0xfc, 0x9d, 0x66, 0x33, 0x10, 0x28, 0x1b, 0x54, 0x1d, 0x81,
		0xf1, 0x88, 0x9a, 0x6b, 0xb7, 0x1b, 0x7f, 0x36, 0x79, 0xce, 0x02, 0xec,
		0x7c, 0x7e, 0x71, 0x37, 0x05, 0x46, 0x33, 0xee, 0x3d, 0x71, 0x8f, 0xb6,
		0x16, 0x6c, 0xa6, 0x64, 0xa9, 0xe4, 0x04, 0xc8, 0x12, 0xd7, 0x14, 0xcf,
		0xed };
unsigned int rsa1024_der_len = 609;

unsigned char rsa1024_pub_der[] = { 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09,
		0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,
		0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xc4, 0x32,
		0x70, 0x15, 0xb3, 0x53, 0xd5, 0xaf, 0x26, 0xc2, 0xcd, 0x6e, 0x87, 0x9f,
		0x13, 0x10, 0x9e, 0x3d, 0x8d, 0x6c, 0xb4, 0x1e, 0xc8, 0xbb, 0xf1, 0xbf,
		0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f, 0x83, 0xd8, 0xe3, 0xf7, 0xe8,
		0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49, 0x6d, 0x38, 0x1d, 0x12, 0x74,
		0xba, 0x9c, 0xb4, 0x38, 0x61, 0x6b, 0x44, 0x1d, 0xac, 0xf7, 0xa7, 0x7d,
		0x8a, 0x80, 0x9f, 0x56, 0x67, 0xb2, 0xe5, 0x45, 0xbc, 0x0d, 0xde, 0xde,
		0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2, 0xf9, 0xfa, 0xe4, 0x3b, 0xa6,
		0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68, 0x85, 0x3c, 0x1b, 0x92, 0xe1,
		0x6c, 0x42, 0x37, 0xe3, 0x1b, 0x7c, 0x7a, 0x25, 0x91, 0x30, 0xd5, 0xa5,
		0xf3, 0xbb, 0x91, 0x23, 0xdf, 0x23, 0x94, 0xb8, 0xf2, 0x61, 0x4f, 0xba,
		0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01 };
unsigned int rsa1024_pub_der_len = 162;

unsigned char rsa2048_der[] = {
  0x30, 0x82, 0x04, 0xa3, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00,
  0xf2, 0x6a, 0x52, 0xa0, 0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4, 0x35, 0x39,
  0x5e, 0x28, 0xd3, 0xa6, 0xab, 0x80, 0x6a, 0xbb, 0x07, 0x10, 0x74, 0xea,
  0xe0, 0xfc, 0xef, 0x54, 0xb0, 0x5e, 0x66, 0x34, 0x21, 0x89, 0x35, 0x09,
  0xb7, 0x46, 0xf8, 0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5, 0x2e, 0x36,
  0xcc, 0xb7, 0x24, 0x5e, 0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d, 0x7b, 0xe1,
  0x4b, 0x9e, 0xdf, 0x08, 0x5c, 0xb2, 0x28, 0xc0, 0x79, 0x45, 0xd1, 0xf3,
  0x9c, 0x70, 0xd8, 0xaf, 0x50, 0x1c, 0xc3, 0x10, 0x24, 0x84, 0xc1, 0xb1,
  0x36, 0x3f, 0xd4, 0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea, 0xce, 0xbf,
  0x34, 0x8e, 0xb5, 0x97, 0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed, 0x1f, 0xe3,
  0xa9, 0xde, 0x5b, 0x3f, 0xc9, 0x33, 0x4c, 0x9b, 0x3e, 0xd8, 0x29, 0x61,
  0x6b, 0x30, 0xba, 0xa1, 0x36, 0xbd, 0x22, 0x33, 0xa1, 0x25, 0x73, 0xab,
  0x5f, 0x6f, 0x35, 0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c, 0xe5, 0xe9,
  0x8d, 0xf9, 0xed, 0x0c, 0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b, 0x9e, 0xbc,
  0xf9, 0xfa, 0x19, 0x51, 0x37, 0x03, 0x5c, 0xd0, 0x25, 0x1f, 0xe6, 0xb2,
  0xf7, 0xff, 0x96, 0xb0, 0x61, 0x42, 0xbb, 0xc5, 0x64, 0x5f, 0x3d, 0xaf,
  0x6f, 0x14, 0xcc, 0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9, 0xe1, 0x4d,
  0x42, 0x76, 0xab, 0x88, 0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6, 0xf7, 0x78,
  0x0c, 0xba, 0x08, 0x71, 0xbc, 0x8d, 0x98, 0x43, 0x12, 0x63, 0x8d, 0x5e,
  0x1f, 0x49, 0xb9, 0x5f, 0x0d, 0x55, 0x1a, 0x90, 0x63, 0x4c, 0xd8, 0xe8,
  0x0b, 0x9f, 0x3d, 0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43, 0xad, 0x35,
  0x42, 0x3d, 0x3d, 0x21, 0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19, 0x14, 0x28,
  0x1c, 0x95, 0xb7, 0x5d, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01,
  0x00, 0x17, 0xd3, 0x1d, 0x45, 0xcd, 0x2b, 0xa7, 0x6a, 0xde, 0x07, 0x31,
  0x97, 0xee, 0xca, 0x22, 0x6b, 0x0a, 0x05, 0xf7, 0xf7, 0x63, 0xad, 0x59,
  0x60, 0x50, 0x36, 0x6b, 0xab, 0x2e, 0x1e, 0x48, 0xfb, 0x2c, 0xa4, 0x98,
  0x82, 0xd8, 0xf1, 0x6f, 0xb6, 0x43, 0xdc, 0xb2, 0x80, 0x7b, 0xa5, 0x9b,
  0x72, 0x25, 0x52, 0x86, 0x8f, 0x83, 0x04, 0x8f, 0x0d, 0x48, 0x40, 0xd2,
  0x81, 0x04, 0xf6, 0x9b, 0x42, 0xee, 0x21, 0x50, 0x62, 0x02, 0x49, 0x3b,
  0x66, 0x2e, 0xe4, 0xe4, 0x56, 0xee, 0x8f, 0xb5, 0x18, 0x1c, 0x0e, 0xb4,
  0x1e, 0x9f, 0x8f, 0x4c, 0x70, 0x6e, 0xbb, 0x95, 0xa9, 0xc7, 0xf1, 0x8d,
  0xda, 0x3a, 0xe7, 0x1f, 0xaf, 0xc8, 0x80, 0x53, 0xe4, 0xbb, 0x39, 0x97,
  0xdd, 0xbf, 0x2f, 0x2c, 0x56, 0xab, 0x86, 0x90, 0x2b, 0xdd, 0xd4, 0x4e,
  0xd4, 0xd5, 0x3d, 0x17, 0xca, 0x8a, 0x5f, 0xb2, 0x41, 0xa1, 0xc6, 0x52,
  0x80, 0xe5, 0xf0, 0x7a, 0xda, 0x35, 0xa5, 0x36, 0xb9, 0x61, 0x15, 0x60,
  0x39, 0x2f, 0x04, 0x1f, 0x6e, 0xee, 0x99, 0xee, 0xa5, 0x21, 0xcc, 0x4f,
  0xa3, 0x4e, 0x06, 0xc5, 0xbc, 0xa5, 0x34, 0xd6, 0x10, 0x57, 0x36, 0x85,
  0xf7, 0x0a, 0x34, 0xfb, 0xa5, 0x6b, 0x71, 0x9c, 0x4a, 0x43, 0x4a, 0xd0,
  0xcb, 0xb4, 0x9a, 0xac, 0x4f, 0x9a, 0x29, 0xe8, 0x68, 0x15, 0x00, 0xe4,
  0x6c, 0x34, 0xc3, 0x73, 0x7e, 0xb5, 0x16, 0x2a, 0x17, 0x37, 0xc0, 0xb6,
  0xaf, 0x81, 0xb4, 0x73, 0xf2, 0xd3, 0x9f, 0xaa, 0x40, 0x73, 0x28, 0x0d,
  0xfd, 0xb4, 0x67, 0x6e, 0x82, 0xa8, 0x13, 0x34, 0xc0, 0x54, 0x88, 0xaf,
  0x85, 0x6f, 0xd8, 0x33, 0x84, 0x82, 0xb5, 0xd0, 0x5f, 0x7f, 0x21, 0xca,
  0x6d, 0x86, 0x74, 0xb3, 0x89, 0x81, 0x19, 0x45, 0x47, 0x38, 0x41, 0x53,
  0x47, 0x86, 0xc6, 0xcd, 0x9d, 0x02, 0x81, 0x81, 0x00, 0xfd, 0x90, 0x23,
  0xf9, 0xba, 0xc5, 0x69, 0x7d, 0x11, 0xed, 0x69, 0x57, 0x73, 0x1d, 0x06,
  0xe8, 0x1b, 0x37, 0x00, 0x69, 0x95, 0xc5, 0x63, 0x86, 0x3f, 0xda, 0xb4,
  0x11, 0xad, 0x69, 0x55, 0xf4, 0x76, 0x3c, 0xa0, 0x95, 0x65, 0x60, 0x29,
  0xb9, 0x69, 0x79, 0xca, 0x74, 0x50, 0xe3, 0x98, 0xc7, 0x90, 0xd7, 0xb8,
  0xd4, 0xc5, 0x51, 0x10, 0xa3, 0x10, 0x72, 0xf3, 0xdc, 0x91, 0xb4, 0xee,
  0xdd, 0x9a, 0x57, 0xf1, 0x1b, 0x0e, 0xba, 0x0f, 0x67, 0x1a, 0x94, 0x86,
  0x36, 0x69, 0x20, 0xd5, 0x6b, 0x80, 0x50, 0x7d, 0x20, 0x53, 0xeb, 0xed,
  0x8a, 0xc5, 0xbc, 0xcb, 0x13, 0xb9, 0x0d, 0x49, 0x22, 0x7c, 0xeb, 0xa6,
  0x97, 0x5a, 0x5b, 0x92, 0x3a, 0x3d, 0x93, 0x5b, 0x86, 0x2c, 0x75, 0x0b,
  0xfa, 0x68, 0xa6, 0xc1, 0x68, 0x07, 0x37, 0x01, 0x9b, 0xd1, 0x51, 0xfe,
  0xc0, 0x4c, 0x2d, 0x15, 0x9f, 0x02, 0x81, 0x81, 0x00, 0xf4, 0xbe, 0xc1,
  0x32, 0xad, 0xca, 0x28, 0x37, 0x7c, 0x17, 0x99, 0xde, 0x64, 0x9b, 0xc1,
  0xf8, 0x23, 0x6a, 0xde, 0xd8, 0x01, 0x59, 0x09, 0x10, 0x67, 0xb8, 0x27,
  0xc5, 0xe6, 0xee, 0xf8, 0x16, 0x7c, 0x46, 0xa0, 0x0b, 0x00, 0xf9, 0xff,
  0x72, 0x4b, 0xde, 0x65, 0x65, 0xb6, 0xaa, 0x44, 0x1a, 0xbc, 0xdf, 0x13,
  0x15, 0x08, 0x80, 0xa5, 0xb4, 0xdd, 0xcd, 0xe0, 0x34, 0x4a, 0x85, 0x31,
  0x82, 0x17, 0x57, 0x5a, 0xea, 0x21, 0x38, 0x26, 0xdf, 0x48, 0x59, 0x1d,
  0x58, 0x5b, 0x9f, 0x04, 0x12, 0xee, 0x5b, 0xa2, 0xa9, 0xb3, 0xfe, 0x83,
  0xa7, 0xda, 0x47, 0xc6, 0xfb, 0x89, 0x77, 0x1f, 0x3a, 0xbc, 0x7c, 0xc7,
  0x13, 0xc9, 0xb8, 0xdc, 0xb0, 0x9e, 0xa7, 0x2a, 0xa5, 0x2c, 0x3b, 0x96,
  0xe2, 0x2e, 0xc0, 0xcf, 0xfa, 0x0c, 0xe0, 0x2d, 0xad, 0xaa, 0x7f, 0x85,
  0x4b, 0x6f, 0x04, 0xf9, 0x83, 0x02, 0x81, 0x81, 0x00, 0xca, 0x8f, 0xd2,
  0xdd, 0x96, 0xc2, 0x4c, 0x52, 0x58, 0xf7, 0x03, 0x77, 0x94, 0x03, 0x75,
  0x58, 0x09, 0x1d, 0xb8, 0x5b, 0xa1, 0x05, 0x4e, 0x4b, 0x9a, 0x49, 0x5a,
  0x1e, 0xe1, 0x1c, 0xcc, 0x48, 0xfe, 0x07, 0xd2, 0xf5, 0x66, 0x46, 0x1b,
  0x2e, 0xfe, 0xbf, 0x07, 0xe8, 0x42, 0x12, 0x80, 0x23, 0xb5, 0x67, 0x50,
  0x45, 0xd1, 0xd7, 0xbf, 0xe5, 0xb4, 0xa7, 0x50, 0x7f, 0x3d, 0x7b, 0x80,
  0x73, 0x51, 0xf0, 0xbd, 0x31, 0x33, 0x63, 0x9a, 0x18, 0x70, 0xd8, 0x84,
  0x1b, 0x85, 0x82, 0x70, 0x5c, 0x6f, 0xe6, 0x5c, 0xff, 0x6d, 0x6b, 0x85,
  0x99, 0x9d, 0xfc, 0x03, 0x73, 0x9f, 0x1a, 0xa8, 0xf9, 0x3f, 0x38, 0x76,
  0x1e, 0x65, 0x55, 0xd0, 0x0c, 0x6c, 0xd2, 0x82, 0x84, 0x3e, 0x91, 0xc6,
  0xde, 0xe5, 0xa9, 0x89, 0xca, 0x54, 0x31, 0x32, 0x3c, 0xcb, 0x4c, 0xa8,
  0xa9, 0xf0, 0x70, 0xf7, 0xdb, 0x02, 0x81, 0x80, 0x62, 0x16, 0xd9, 0xa3,
  0x90, 0x17, 0x87, 0x8a, 0xc5, 0x47, 0x48, 0x39, 0xe3, 0xa4, 0xb1, 0x56,
  0xdc, 0x0b, 0x07, 0x09, 0x17, 0x71, 0x31, 0xba, 0xcb, 0x76, 0xf9, 0x29,
  0xcd, 0xe6, 0x54, 0xb3, 0xde, 0x57, 0x07, 0xe9, 0xa1, 0x18, 0x91, 0x12,
  0xa3, 0xe9, 0x9c, 0x45, 0xe9, 0xb1, 0xcf, 0xdd, 0xcf, 0x78, 0xb0, 0x53,
  0x2b, 0xb7, 0x33, 0xb2, 0x8b, 0x7a, 0xe9, 0xb2, 0xcb, 0x73, 0x1a, 0x66,
  0x83, 0x28, 0x55, 0x9d, 0xa4, 0x76, 0xb6, 0xcd, 0xa2, 0x57, 0x64, 0xf5,
  0x76, 0xb3, 0x02, 0x94, 0xfb, 0xc6, 0xea, 0x28, 0x8d, 0xa5, 0x21, 0xea,
  0xf2, 0x06, 0xf6, 0x6e, 0xf5, 0xa7, 0x32, 0x72, 0xfd, 0xfc, 0x1c, 0x65,
  0x87, 0xe1, 0x79, 0x41, 0xa8, 0x34, 0x63, 0x59, 0x13, 0xa3, 0x46, 0x53,
  0x9c, 0x5d, 0x56, 0x7d, 0x67, 0x0f, 0xa9, 0xff, 0x02, 0x68, 0x5d, 0x69,
  0xe0, 0x32, 0xe4, 0x35, 0x02, 0x81, 0x80, 0x55, 0xf8, 0x25, 0x84, 0x94,
  0xad, 0x50, 0xab, 0x49, 0x38, 0x30, 0xaf, 0xde, 0x53, 0xdc, 0x27, 0x08,
  0x25, 0x27, 0x5a, 0xd2, 0xe5, 0x21, 0x50, 0xde, 0x6d, 0x6b, 0xc7, 0x17,
  0xae, 0x21, 0xb6, 0xcb, 0xe9, 0x24, 0x7c, 0x76, 0x32, 0xe3, 0xcb, 0xba,
  0xee, 0x61, 0xd2, 0x79, 0xf2, 0x88, 0x12, 0x1c, 0x9f, 0x29, 0xb3, 0x6a,
  0x73, 0x16, 0xfc, 0x35, 0xcf, 0xe7, 0x68, 0xec, 0x47, 0xf7, 0xfb, 0x2d,
  0x18, 0xff, 0xa8, 0xbf, 0xe1, 0xe8, 0x64, 0xa0, 0x98, 0x4a, 0x70, 0x07,
  0x5d, 0xb1, 0x8e, 0x6e, 0x15, 0x4e, 0x0d, 0x28, 0x61, 0xb1, 0x37, 0x21,
  0xcb, 0xba, 0x1d, 0x1b, 0xff, 0x06, 0x9f, 0xbe, 0xbc, 0xa9, 0x93, 0x77,
  0x07, 0xc1, 0xc0, 0x1a, 0x4b, 0x13, 0xee, 0xa3, 0xdb, 0x7e, 0x99, 0x94,
  0xcc, 0x5b, 0x88, 0xfb, 0xb9, 0x77, 0x3c, 0x81, 0x80, 0x5d, 0xef, 0x3e,
  0xf8, 0x6e, 0xfa
};
unsigned int rsa2048_der_len = 1191;

unsigned char rsa2048_pub_der[] = {
  0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
  0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
  0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xf2, 0x6a, 0x52,
  0xa0, 0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4, 0x35, 0x39, 0x5e, 0x28, 0xd3,
  0xa6, 0xab, 0x80, 0x6a, 0xbb, 0x07, 0x10, 0x74, 0xea, 0xe0, 0xfc, 0xef,
  0x54, 0xb0, 0x5e, 0x66, 0x34, 0x21, 0x89, 0x35, 0x09, 0xb7, 0x46, 0xf8,
  0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5, 0x2e, 0x36, 0xcc, 0xb7, 0x24,
  0x5e, 0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d, 0x7b, 0xe1, 0x4b, 0x9e, 0xdf,
  0x08, 0x5c, 0xb2, 0x28, 0xc0, 0x79, 0x45, 0xd1, 0xf3, 0x9c, 0x70, 0xd8,
  0xaf, 0x50, 0x1c, 0xc3, 0x10, 0x24, 0x84, 0xc1, 0xb1, 0x36, 0x3f, 0xd4,
  0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea, 0xce, 0xbf, 0x34, 0x8e, 0xb5,
  0x97, 0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed, 0x1f, 0xe3, 0xa9, 0xde, 0x5b,
  0x3f, 0xc9, 0x33, 0x4c, 0x9b, 0x3e, 0xd8, 0x29, 0x61, 0x6b, 0x30, 0xba,
  0xa1, 0x36, 0xbd, 0x22, 0x33, 0xa1, 0x25, 0x73, 0xab, 0x5f, 0x6f, 0x35,
  0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c, 0xe5, 0xe9, 0x8d, 0xf9, 0xed,
  0x0c, 0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b, 0x9e, 0xbc, 0xf9, 0xfa, 0x19,
  0x51, 0x37, 0x03, 0x5c, 0xd0, 0x25, 0x1f, 0xe6, 0xb2, 0xf7, 0xff, 0x96,
  0xb0, 0x61, 0x42, 0xbb, 0xc5, 0x64, 0x5f, 0x3d, 0xaf, 0x6f, 0x14, 0xcc,
  0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9, 0xe1, 0x4d, 0x42, 0x76, 0xab,
  0x88, 0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6, 0xf7, 0x78, 0x0c, 0xba, 0x08,
  0x71, 0xbc, 0x8d, 0x98, 0x43, 0x12, 0x63, 0x8d, 0x5e, 0x1f, 0x49, 0xb9,
  0x5f, 0x0d, 0x55, 0x1a, 0x90, 0x63, 0x4c, 0xd8, 0xe8, 0x0b, 0x9f, 0x3d,
  0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43, 0xad, 0x35, 0x42, 0x3d, 0x3d,
  0x21, 0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19, 0x14, 0x28, 0x1c, 0x95, 0xb7,
  0x5d, 0x02, 0x03, 0x01, 0x00, 0x01
};
unsigned int rsa2048_pub_der_len = 294;

unsigned char rsa1024_cert_der[] = {
  0x30, 0x82, 0x02, 0xb4, 0x30, 0x82, 0x02, 0x1d, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x09, 0x00, 0xc4, 0x52, 0xc1, 0x4a, 0x9e, 0x74, 0xe8, 0xa8,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
  0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03,
  0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e,
  0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08,
  0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69, 0x61, 0x31, 0x10, 0x30, 0x0e,
  0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x07, 0x43, 0x6f, 0x6d, 0x63, 0x61,
  0x73, 0x74, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c,
  0x06, 0x43, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x31, 0x1b, 0x30, 0x19, 0x06,
  0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63,
  0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
  0x30, 0x1e, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x36, 0x32, 0x33, 0x30, 0x33,
  0x30, 0x35, 0x31, 0x36, 0x5a, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x37, 0x32,
  0x33, 0x30, 0x33, 0x30, 0x35, 0x31, 0x36, 0x5a, 0x30, 0x73, 0x31, 0x0b,
  0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
  0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61,
  0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03,
  0x55, 0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69,
  0x61, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x07,
  0x43, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x31, 0x0f, 0x30, 0x0d, 0x06,
  0x03, 0x55, 0x04, 0x0b, 0x0c, 0x06, 0x43, 0x6f, 0x6e, 0x73, 0x65, 0x63,
  0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63,
  0x6f, 0x6e, 0x73, 0x65, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73,
  0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09,
  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,
  0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xc4, 0x32,
  0x70, 0x15, 0xb3, 0x53, 0xd5, 0xaf, 0x26, 0xc2, 0xcd, 0x6e, 0x87, 0x9f,
  0x13, 0x10, 0x9e, 0x3d, 0x8d, 0x6c, 0xb4, 0x1e, 0xc8, 0xbb, 0xf1, 0xbf,
  0x7a, 0xc0, 0xce, 0xbf, 0x5c, 0x00, 0x1f, 0x83, 0xd8, 0xe3, 0xf7, 0xe8,
  0xa3, 0x79, 0x61, 0xd4, 0x3a, 0xae, 0x49, 0x6d, 0x38, 0x1d, 0x12, 0x74,
  0xba, 0x9c, 0xb4, 0x38, 0x61, 0x6b, 0x44, 0x1d, 0xac, 0xf7, 0xa7, 0x7d,
  0x8a, 0x80, 0x9f, 0x56, 0x67, 0xb2, 0xe5, 0x45, 0xbc, 0x0d, 0xde, 0xde,
  0x63, 0x06, 0x13, 0x4d, 0x06, 0x2e, 0xe2, 0xf9, 0xfa, 0xe4, 0x3b, 0xa6,
  0xa0, 0x49, 0xbb, 0x11, 0x23, 0xf8, 0x68, 0x85, 0x3c, 0x1b, 0x92, 0xe1,
  0x6c, 0x42, 0x37, 0xe3, 0x1b, 0x7c, 0x7a, 0x25, 0x91, 0x30, 0xd5, 0xa5,
  0xf3, 0xbb, 0x91, 0x23, 0xdf, 0x23, 0x94, 0xb8, 0xf2, 0x61, 0x4f, 0xba,
  0x73, 0xd1, 0x4b, 0x2b, 0x89, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3,
  0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
  0x04, 0x14, 0x76, 0x63, 0x9b, 0x06, 0xa5, 0x12, 0x26, 0xa5, 0x89, 0xc6,
  0x6c, 0x57, 0x5b, 0x4a, 0x3e, 0x47, 0xb0, 0xa4, 0x0b, 0x1a, 0x30, 0x1f,
  0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x76,
  0x63, 0x9b, 0x06, 0xa5, 0x12, 0x26, 0xa5, 0x89, 0xc6, 0x6c, 0x57, 0x5b,
  0x4a, 0x3e, 0x47, 0xb0, 0xa4, 0x0b, 0x1a, 0x30, 0x0c, 0x06, 0x03, 0x55,
  0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,
  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
  0x03, 0x81, 0x81, 0x00, 0x33, 0xbe, 0xfe, 0x79, 0xdb, 0x9b, 0xc2, 0x09,
  0xb8, 0x9c, 0x51, 0x6a, 0x2b, 0x5f, 0xe5, 0xc6, 0xc6, 0xd2, 0x72, 0x5d,
  0x56, 0x24, 0xa1, 0xa5, 0xac, 0x28, 0xbc, 0xba, 0x60, 0xb9, 0xd6, 0x30,
  0x39, 0x4e, 0x89, 0xc9, 0x41, 0x89, 0x37, 0xf0, 0xeb, 0xee, 0x09, 0x31,
  0xb0, 0x34, 0xed, 0xf6, 0x8f, 0x70, 0xd3, 0x65, 0x81, 0x18, 0x1c, 0xbe,
  0xd0, 0x08, 0x94, 0x1d, 0x80, 0x92, 0x72, 0x8f, 0x16, 0xa4, 0xac, 0xf4,
  0x7d, 0x1e, 0xe1, 0x8b, 0xe7, 0x79, 0x26, 0x4b, 0xc8, 0x17, 0x3e, 0x19,
  0xf5, 0x50, 0x07, 0xd0, 0x85, 0xb6, 0xeb, 0x56, 0xff, 0xdb, 0xe2, 0x28,
  0x42, 0x58, 0x52, 0xf3, 0xef, 0x6a, 0xf8, 0x86, 0xae, 0x9e, 0xa2, 0x7c,
  0xa2, 0xb7, 0x87, 0x90, 0x1b, 0x48, 0xdc, 0x7d, 0x2a, 0xf2, 0x0c, 0x55,
  0xf3, 0x34, 0x79, 0xb3, 0x87, 0x67, 0x18, 0x29, 0xc8, 0x3a, 0xc9, 0xe3
};
unsigned int rsa1024_cert_der_len = 696;

unsigned char rsa2048_cert_der[] = {
  0x30, 0x82, 0x03, 0xb9, 0x30, 0x82, 0x02, 0xa1, 0xa0, 0x03, 0x02, 0x01,
  0x02, 0x02, 0x09, 0x00, 0xee, 0x91, 0x7a, 0x08, 0x9a, 0x55, 0x9f, 0x5f,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
  0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03,
  0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61, 0x72, 0x79, 0x6c, 0x61, 0x6e,
  0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08,
  0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69, 0x61, 0x31, 0x0f, 0x30, 0x0d,
  0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06, 0x43, 0x6f, 0x6e, 0x73, 0x65,
  0x63, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x07,
  0x43, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x31, 0x1b, 0x30, 0x19, 0x06,
  0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63,
  0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
  0x30, 0x1e, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x36, 0x32, 0x33, 0x30, 0x33,
  0x30, 0x36, 0x30, 0x37, 0x5a, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x37, 0x32,
  0x33, 0x30, 0x33, 0x30, 0x36, 0x30, 0x37, 0x5a, 0x30, 0x73, 0x31, 0x0b,
  0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
  0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x08, 0x4d, 0x61,
  0x72, 0x79, 0x6c, 0x61, 0x6e, 0x64, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03,
  0x55, 0x04, 0x07, 0x0c, 0x08, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x62, 0x69,
  0x61, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x06,
  0x43, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03,
  0x55, 0x04, 0x0b, 0x0c, 0x07, 0x43, 0x6f, 0x6d, 0x63, 0x61, 0x73, 0x74,
  0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x12, 0x63,
  0x6f, 0x6e, 0x73, 0x65, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x63, 0x61, 0x73,
  0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06,
  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00,
  0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01,
  0x01, 0x00, 0xf2, 0x6a, 0x52, 0xa0, 0x96, 0xc5, 0xb7, 0x86, 0x6f, 0xc4,
  0x35, 0x39, 0x5e, 0x28, 0xd3, 0xa6, 0xab, 0x80, 0x6a, 0xbb, 0x07, 0x10,
  0x74, 0xea, 0xe0, 0xfc, 0xef, 0x54, 0xb0, 0x5e, 0x66, 0x34, 0x21, 0x89,
  0x35, 0x09, 0xb7, 0x46, 0xf8, 0xb6, 0xf8, 0x86, 0xc0, 0x55, 0xc6, 0xc5,
  0x2e, 0x36, 0xcc, 0xb7, 0x24, 0x5e, 0x56, 0xba, 0x2b, 0x8d, 0xfb, 0x8d,
  0x7b, 0xe1, 0x4b, 0x9e, 0xdf, 0x08, 0x5c, 0xb2, 0x28, 0xc0, 0x79, 0x45,
  0xd1, 0xf3, 0x9c, 0x70, 0xd8, 0xaf, 0x50, 0x1c, 0xc3, 0x10, 0x24, 0x84,
  0xc1, 0xb1, 0x36, 0x3f, 0xd4, 0xbf, 0x10, 0x18, 0xf9, 0xd0, 0x72, 0xea,
  0xce, 0xbf, 0x34, 0x8e, 0xb5, 0x97, 0xcb, 0x8a, 0x5e, 0x8e, 0x7d, 0xed,
  0x1f, 0xe3, 0xa9, 0xde, 0x5b, 0x3f, 0xc9, 0x33, 0x4c, 0x9b, 0x3e, 0xd8,
  0x29, 0x61, 0x6b, 0x30, 0xba, 0xa1, 0x36, 0xbd, 0x22, 0x33, 0xa1, 0x25,
  0x73, 0xab, 0x5f, 0x6f, 0x35, 0x48, 0xf1, 0xad, 0x96, 0x5f, 0x0d, 0x0c,
  0xe5, 0xe9, 0x8d, 0xf9, 0xed, 0x0c, 0xcf, 0x50, 0x3c, 0x24, 0x34, 0x9b,
  0x9e, 0xbc, 0xf9, 0xfa, 0x19, 0x51, 0x37, 0x03, 0x5c, 0xd0, 0x25, 0x1f,
  0xe6, 0xb2, 0xf7, 0xff, 0x96, 0xb0, 0x61, 0x42, 0xbb, 0xc5, 0x64, 0x5f,
  0x3d, 0xaf, 0x6f, 0x14, 0xcc, 0x92, 0x74, 0x6a, 0x06, 0xfa, 0xb2, 0xd9,
  0xe1, 0x4d, 0x42, 0x76, 0xab, 0x88, 0xe3, 0x08, 0xa2, 0xad, 0x00, 0xb6,
  0xf7, 0x78, 0x0c, 0xba, 0x08, 0x71, 0xbc, 0x8d, 0x98, 0x43, 0x12, 0x63,
  0x8d, 0x5e, 0x1f, 0x49, 0xb9, 0x5f, 0x0d, 0x55, 0x1a, 0x90, 0x63, 0x4c,
  0xd8, 0xe8, 0x0b, 0x9f, 0x3d, 0x10, 0xb4, 0xf9, 0x1b, 0x44, 0x3f, 0x43,
  0xad, 0x35, 0x42, 0x3d, 0x3d, 0x21, 0x8e, 0xa8, 0x08, 0x28, 0x47, 0x19,
  0x14, 0x28, 0x1c, 0x95, 0xb7, 0x5d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3,
  0x50, 0x30, 0x4e, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
  0x04, 0x14, 0xf0, 0xe1, 0x4e, 0x26, 0x9b, 0xa4, 0xc8, 0x7c, 0x24, 0x2d,
  0xa2, 0xdc, 0x5e, 0x3e, 0xb8, 0x64, 0xb0, 0xb7, 0x3e, 0x96, 0x30, 0x1f,
  0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xf0,
  0xe1, 0x4e, 0x26, 0x9b, 0xa4, 0xc8, 0x7c, 0x24, 0x2d, 0xa2, 0xdc, 0x5e,
  0x3e, 0xb8, 0x64, 0xb0, 0xb7, 0x3e, 0x96, 0x30, 0x0c, 0x06, 0x03, 0x55,
  0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,
  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
  0x03, 0x82, 0x01, 0x01, 0x00, 0x68, 0x60, 0x3a, 0x9a, 0xcf, 0x75, 0x6c,
  0x09, 0xab, 0x9a, 0x4a, 0x0d, 0x9b, 0xe4, 0x7f, 0xdc, 0x7a, 0xa9, 0xfa,
  0x06, 0xb4, 0xc4, 0xca, 0xcf, 0xa0, 0x38, 0x7f, 0xdf, 0xc2, 0x4d, 0x4a,
  0x94, 0x82, 0x33, 0x83, 0x9a, 0x7b, 0x9b, 0x84, 0xf7, 0xfd, 0xb3, 0x93,
  0x22, 0xd0, 0xb2, 0x73, 0xa8, 0x54, 0x45, 0xb0, 0x05, 0xac, 0x1a, 0xff,
  0x60, 0x03, 0x54, 0xa7, 0x0d, 0xcb, 0x8d, 0xeb, 0x62, 0x59, 0xcb, 0x8b,
  0xfa, 0x7f, 0x8d, 0xd8, 0xa4, 0x64, 0x3a, 0x3e, 0xdc, 0x5d, 0xb9, 0xc0,
  0x27, 0x50, 0xd0, 0x54, 0x62, 0x1e, 0xe7, 0x7f, 0x66, 0xa8, 0xdf, 0xbc,
  0x6a, 0x17, 0xf1, 0xcd, 0x45, 0x76, 0x34, 0xc3, 0x6c, 0x6f, 0xac, 0x85,
  0x50, 0xdc, 0xd4, 0xf0, 0xdd, 0x85, 0xfa, 0x75, 0x23, 0x45, 0x12, 0x90,
  0x0d, 0xf2, 0xc9, 0x43, 0x83, 0x4c, 0x97, 0xfd, 0x76, 0x64, 0xa8, 0x80,
  0x15, 0x45, 0x4a, 0xa4, 0x36, 0xc7, 0xa5, 0x12, 0x09, 0x4d, 0xc1, 0xdb,
  0xc0, 0xbe, 0x58, 0x9b, 0x16, 0xe6, 0x6f, 0x63, 0xed, 0x5c, 0x62, 0xd6,
  0x23, 0xb0, 0x26, 0x46, 0xb1, 0x98, 0x5c, 0x94, 0x72, 0x86, 0x2f, 0x26,
  0xa1, 0x91, 0x68, 0x4a, 0x5c, 0x01, 0x8b, 0x44, 0x00, 0xea, 0xa4, 0x61,
  0x85, 0x4b, 0xd4, 0xc3, 0x50, 0x16, 0x97, 0xa4, 0x6f, 0x56, 0x2f, 0x2a,
  0xf0, 0x6e, 0x3f, 0x35, 0x6e, 0xe5, 0x27, 0x3c, 0x76, 0xa9, 0x91, 0x6b,
  0x1f, 0x1e, 0x73, 0x82, 0x61, 0xcc, 0x06, 0x2d, 0xae, 0x12, 0x49, 0x66,
  0xa6, 0x86, 0x39, 0x65, 0x00, 0x77, 0x22, 0x92, 0x64, 0x9c, 0x12, 0x30,
  0x24, 0x75, 0x8b, 0xd7, 0x02, 0x7a, 0x5b, 0xbe, 0x15, 0xda, 0x0e, 0xac,
  0x9c, 0xfe, 0xb1, 0xc8, 0x6c, 0x25, 0xf8, 0xea, 0x0a, 0x69, 0x64, 0xb7,
  0x5e, 0x60, 0x65, 0xba, 0x02, 0xe4, 0xf5, 0x66, 0x07
};
unsigned int rsa2048_cert_der_len = 957;

unsigned char ecc_der[] = {
  0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x4d, 0xef, 0x8c, 0x19, 0x60,
  0xf5, 0xd6, 0x78, 0x18, 0x84, 0x4d, 0xe6, 0xe3, 0x2f, 0x19, 0x4f, 0xcd,
  0x10, 0xc5, 0xfd, 0x55, 0x54, 0xc1, 0x7e, 0x95, 0x4e, 0xbc, 0xe1, 0xba,
  0xba, 0x56, 0xc6, 0xa0, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
  0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a,
  0x21, 0x09, 0x41, 0xb2, 0x02, 0x5b, 0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e,
  0xae, 0xae, 0x21, 0xd8, 0x02, 0x8e, 0xaa, 0x3b, 0x68, 0x03, 0x6e, 0x25,
  0xd6, 0x2c, 0x08, 0xff, 0xa6, 0x13, 0x5a, 0x8c, 0x14, 0xe0, 0x93, 0x66,
  0xa2, 0x25, 0x46, 0x75, 0x8f, 0xd6, 0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e,
  0xa8, 0xed, 0x45, 0xb1, 0xe5, 0x91, 0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d,
  0x94
};
unsigned int ecc_der_len = 121;

unsigned char ecc_pub_der[] = {
  0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
  0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03,
  0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a, 0x21, 0x09, 0x41, 0xb2, 0x02, 0x5b,
  0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e, 0xae, 0xae, 0x21, 0xd8, 0x02, 0x8e,
  0xaa, 0x3b, 0x68, 0x03, 0x6e, 0x25, 0xd6, 0x2c, 0x08, 0xff, 0xa6, 0x13,
  0x5a, 0x8c, 0x14, 0xe0, 0x93, 0x66, 0xa2, 0x25, 0x46, 0x75, 0x8f, 0xd6,
  0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e, 0xa8, 0xed, 0x45, 0xb1, 0xe5, 0x91,
  0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d, 0x94
};
unsigned int ecc_pub_der_len = 91;



unsigned char ecc_cert_der[] = {
  0x30, 0x82, 0x01, 0x7a, 0x30, 0x82, 0x01, 0x20, 0x02, 0x09, 0x00, 0xa6,
  0x4e, 0x60, 0x8c, 0xa5, 0xe7, 0x04, 0x98, 0x30, 0x0a, 0x06, 0x08, 0x2a,
  0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30, 0x45, 0x31, 0x0b, 0x30,
  0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,
  0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x53, 0x6f, 0x6d,
  0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,
  0x03, 0x55, 0x04, 0x0a, 0x0c, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,
  0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,
  0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x38,
  0x31, 0x30, 0x30, 0x39, 0x31, 0x38, 0x31, 0x35, 0x33, 0x31, 0x5a, 0x17,
  0x0d, 0x31, 0x38, 0x31, 0x31, 0x30, 0x38, 0x31, 0x38, 0x31, 0x35, 0x33,
  0x31, 0x5a, 0x30, 0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
  0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,
  0x04, 0x08, 0x0c, 0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61,
  0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c,
  0x18, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69,
  0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20, 0x4c, 0x74,
  0x64, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d,
  0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07,
  0x03, 0x42, 0x00, 0x04, 0x7f, 0xd8, 0x8a, 0x21, 0x09, 0x41, 0xb2, 0x02,
  0x5b, 0x1d, 0xb0, 0x2e, 0xa5, 0x04, 0x6e, 0xae, 0xae, 0x21, 0xd8, 0x02,
  0x8e, 0xaa, 0x3b, 0x68, 0x03, 0x6e, 0x25, 0xd6, 0x2c, 0x08, 0xff, 0xa6,
  0x13, 0x5a, 0x8c, 0x14, 0xe0, 0x93, 0x66, 0xa2, 0x25, 0x46, 0x75, 0x8f,
  0xd6, 0x87, 0x79, 0xb4, 0xc2, 0x62, 0x7e, 0xa8, 0xed, 0x45, 0xb1, 0xe5,
  0x91, 0xb6, 0x2b, 0xd4, 0x2a, 0xbb, 0x2d, 0x94, 0x30, 0x0a, 0x06, 0x08,
  0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30,
  0x45, 0x02, 0x21, 0x00, 0xad, 0xfc, 0x19, 0xb8, 0xc3, 0x87, 0x8d, 0x52,
  0x3a, 0xf5, 0x83, 0xc6, 0x58, 0xc5, 0x86, 0x3b, 0xd5, 0xce, 0x74, 0x85,
  0x66, 0xd5, 0xbc, 0xfe, 0x5f, 0xd1, 0x75, 0xe3, 0x42, 0xe1, 0x5a, 0x00,
  0x02, 0x20, 0x7c, 0x9c, 0xb8, 0x45, 0x9e, 0xe7, 0x3a, 0x52, 0x9b, 0x2c,
  0x92, 0xf3, 0x1b, 0x93, 0x65, 0x47, 0xb3, 0xf1, 0x1b, 0xf4, 0xf6, 0x50,
  0xd2, 0xf4, 0xcb, 0x25, 0x38, 0x21, 0xcb, 0x43, 0xae, 0x7a
};
unsigned int ecc_cert_der_len = 382;

struct TestKeyData {
	Sec_KeyType type;
	Sec_KeyContainer kc;
	SEC_BYTE *buffer;
	SEC_SIZE buffer_len;
};

static TestKeyData g_keyData[TESTKEY_NUM] = {
		{ SEC_KEYTYPE_AES_128, SEC_KEYCONTAINER_RAW_AES_128, sym128_a_bin, sym128_a_bin_len }, //TESTKEY_AES128_A
		{ SEC_KEYTYPE_AES_256, SEC_KEYCONTAINER_RAW_AES_256, sym256_a_bin, sym256_a_bin_len }, //TESTKEY_AES256_A
		{ SEC_KEYTYPE_HMAC_128, SEC_KEYCONTAINER_RAW_HMAC_128, sym128_a_bin, sym128_a_bin_len }, //TESTKEY_HMAC128_A
		{ SEC_KEYTYPE_HMAC_160, SEC_KEYCONTAINER_RAW_HMAC_160, sym160_a_bin, sym160_a_bin_len }, //TESTKEY_HMAC160_A
		{ SEC_KEYTYPE_HMAC_256, SEC_KEYCONTAINER_RAW_HMAC_256, sym256_a_bin, sym256_a_bin_len }, //TESTKEY_HMAC256_A
		{ SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len }, //TESTKEY_RSA1024_SGN_PRIV
		{ SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len }, //TESTKEY_RSA1024_SGN_PUB
        { SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len }, //TESTKEY_RSA1024_ENC_PRIV
        { SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len }, //TESTKEY_RSA1024_ENC_PUB
        { SEC_KEYTYPE_RSA_1024, SEC_KEYCONTAINER_DER_RSA_1024, rsa1024_der, rsa1024_der_len }, //TESTKEY_RSA1024_KEK_PRIV
        { SEC_KEYTYPE_RSA_1024_PUBLIC, SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC, rsa1024_pub_der, rsa1024_pub_der_len }, //TESTKEY_RSA1024_KEK_PUB
		{ SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len }, //TESTKEY_RSA2048_SGN_PRIV
		{ SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len }, //TESTKEY_RSA2048_SGN_PUB
        { SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len }, //TESTKEY_RSA2048_ENC_PRIV
        { SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len }, //TESTKEY_RSA2048_ENC_PUB
        { SEC_KEYTYPE_RSA_2048, SEC_KEYCONTAINER_DER_RSA_2048, rsa2048_der, rsa2048_der_len }, //TESTKEY_RSA2048_KEK_PRIV
        { SEC_KEYTYPE_RSA_2048_PUBLIC, SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC, rsa2048_pub_der, rsa2048_pub_der_len }, //TESTKEY_RSA2048_KEK_PUB
		{ SEC_KEYTYPE_ECC_NISTP256, SEC_KEYCONTAINER_DER_ECC_NISTP256, ecc_der, ecc_der_len }, //TESTKEY_ECC
		{ SEC_KEYTYPE_ECC_NISTP256_PUBLIC, SEC_KEYCONTAINER_DER_ECC_NISTP256_PUBLIC, ecc_pub_der, ecc_pub_der_len }, //TESTKEY_ECC_PUB
		};

struct TestCertData {
	Sec_CertificateContainer cc;
	SEC_BYTE *buffer;
	SEC_SIZE buffer_len;
};

static TestCertData g_certData[TESTKEY_NUM] = {
		{ SEC_CERTIFICATECONTAINER_X509_DER, rsa1024_cert_der, rsa1024_cert_der_len }, //TESTCERT_RSA1024
		{ SEC_CERTIFICATECONTAINER_X509_DER, rsa2048_cert_der, rsa2048_cert_der_len }, //TESTCERT_RSA2048
		{ SEC_CERTIFICATECONTAINER_X509_DER, ecc_cert_der, ecc_cert_der_len }, //TESTCERT_EC
		};

static Sec_Result _BigNumToBuffer(const BIGNUM *bignum, SEC_BYTE *buffer, SEC_SIZE buffer_len)
{
    SEC_SIZE num_bytes;

    memset(buffer, 0, buffer_len);
    num_bytes = BN_num_bytes(bignum);

    if (num_bytes > buffer_len) {
        SEC_LOG_ERROR("buffer not large enough.  needed: %d, actual: %d", num_bytes, buffer_len);
        return SEC_RESULT_FAILURE;
    }

    BN_bn2bin(bignum, buffer + buffer_len - num_bytes);

    return SEC_RESULT_SUCCESS;
}

ProvKey* TestCreds::getKey(TestKey key, TestKc kc, SEC_OBJECTID id) {
	if (key >= TESTKEY_NUM) {
		SEC_LOG_ERROR("Invalid key: %d", key);
		return NULL;
	}

	switch (kc) {
	case TESTKC_RAW:
		return new ProvKey(std::vector<SEC_BYTE> (g_keyData[key].buffer,
				g_keyData[key].buffer + g_keyData[key].buffer_len), g_keyData[key].kc);
		break;

	case TESTKC_SOC:
		return TestCreds::getSocKey(key, id);
		break;

    case TESTKC_GENERATED:
	case TESTKC_STORE:
	default:
		break;
	}

	SEC_LOG_ERROR("Unimplemented");
	return NULL;
}

Sec_KeyType TestCreds::getKeyType(TestKey key) {
	if (key >= TESTKEY_NUM) {
		SEC_LOG_ERROR("Invalid key: %d", key);
		return SEC_KEYTYPE_NUM;
	}

	return g_keyData[key].type;
}

ProvCert *TestCreds::getCert(TestCert cert) {
	if (cert >= TESTCERT_NUM) {
		SEC_LOG_ERROR("Invalid cert: %d", cert);
		return NULL;
	}

	return new ProvCert(std::vector<SEC_BYTE> (g_certData[cert].buffer,
			g_certData[cert].buffer + g_certData[cert].buffer_len), g_certData[cert].cc);
}

std::vector<SEC_BYTE> TestCreds::asOpenSslAes(TestKey key) {
	return std::vector<SEC_BYTE> (g_keyData[key].buffer, g_keyData[key].buffer + g_keyData[key].buffer_len);
}

static RSA *_RSAFromDERPub(SEC_BYTE *der, SEC_SIZE der_len)
{
    const unsigned char *p = (const unsigned char *) der;
    RSA *rsa = NULL;

    rsa = d2i_RSAPublicKey(&rsa, &p, der_len);

    if (!rsa)
    {
        p = (const unsigned char *) der;
        rsa = d2i_RSA_PUBKEY(&rsa, &p, der_len);
    }

    if (!rsa)
    {
        SEC_LOG_ERROR("Invalid RSA key container");
        goto done;
    }

done:
    return rsa;
}

static RSA *_RSAFromDERPriv(SEC_BYTE *der, SEC_SIZE der_len)
{
    const unsigned char *p = (const unsigned char *) der;
    PKCS8_PRIV_KEY_INFO *p8 = NULL;
    EVP_PKEY *evp_key = NULL;
    RSA *rsa = NULL;

    p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, der_len);
    if (p8 != NULL)
    {
        evp_key = EVP_PKCS82PKEY(p8);
        if (evp_key == NULL)
        {
            SEC_LOG_ERROR("EVP_PKCS82PKEY failed");
            goto done;
        }
    }
    else
    {
        evp_key = d2i_AutoPrivateKey(NULL, &p, der_len);
        if (evp_key == NULL)
        {
            SEC_LOG_ERROR("d2i_AutoPrivateKey failed");
            goto done;
        }
    }

    rsa = EVP_PKEY_get1_RSA(evp_key);
    if (rsa == NULL)
    {
        SEC_LOG_ERROR("EVP_PKEY_get1_RSA failed");
        goto done;
    }

done:
    SEC_EVPPKEY_FREE(evp_key);

    if (p8 != NULL)
    {
        PKCS8_PRIV_KEY_INFO_free(p8);
    }

    return rsa;
}

RSA* TestCreds::asOpenSslRsa(TestKey key) {
	RSA *rsa = NULL;
	if (g_keyData[key].kc == SEC_KEYCONTAINER_DER_RSA_1024_PUBLIC
			|| g_keyData[key].kc == SEC_KEYCONTAINER_DER_RSA_2048_PUBLIC) {
		rsa = _RSAFromDERPub(g_keyData[key].buffer, g_keyData[key].buffer_len);
		if (rsa == NULL) {
			SEC_LOG_ERROR("SecUtils_RSAFromDERPub failed");
		}
	} else {
		rsa = _RSAFromDERPriv(g_keyData[key].buffer, g_keyData[key].buffer_len);
		if (rsa == NULL) {
			SEC_LOG_ERROR("SecUtils_RSAFromDERPriv failed");
		}
	}

	return rsa;
}

static EC_KEY *_ECCFromDERPub(SEC_BYTE *der, SEC_SIZE der_len)
{
    const unsigned char *p = (const unsigned char *) der;
    EC_KEY *ec_key = NULL;

    ec_key = d2i_EC_PUBKEY(&ec_key, &p, der_len);

    if (ec_key == NULL)
    {
        SEC_LOG_ERROR("Invalid ECC key container");
        goto done;
    }

done:
    return ec_key;
}

static EC_KEY *_ECCFromDERPriv(SEC_BYTE *der, SEC_SIZE der_len)
{
    const unsigned char *p = (const unsigned char *) der;
    PKCS8_PRIV_KEY_INFO *p8 = NULL;
    EVP_PKEY *evp_key = NULL;
    EC_KEY *ecc = NULL;

    p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, der_len);
    if (p8 != NULL)
    {
        evp_key = EVP_PKCS82PKEY(p8);
        if (evp_key == NULL)
        {
            SEC_LOG_ERROR("EVP_PKCS82PKEY failed");
            goto done;
        }
    }
    else
    {
        evp_key = d2i_AutoPrivateKey(NULL, &p, der_len);
        if (evp_key == NULL)
        {
            SEC_LOG_ERROR("d2i_AutoPrivateKey failed");
            goto done;
        }
    }

    ecc = EVP_PKEY_get1_EC_KEY(evp_key);
    if (ecc == NULL)
    {
        SEC_LOG_ERROR("EVP_PKEY_get1_EC_KEY failed");
        goto done;
    }

done:
    SEC_EVPPKEY_FREE(evp_key);

    if (p8 != NULL)
    {
        PKCS8_PRIV_KEY_INFO_free(p8);
    }

    return ecc;
}

EC_KEY *TestCreds::asOpenSslEcKey(TestKey key) {
	EC_KEY *ec = NULL;
	if (g_keyData[key].kc == SEC_KEYCONTAINER_DER_ECC_NISTP256_PUBLIC) {
		ec = _ECCFromDERPub(g_keyData[key].buffer, g_keyData[key].buffer_len);
		if (ec == NULL) {
			SEC_LOG_ERROR("SecUtils_ECCFromDERPub failed");
		}
	} else {
		ec = _ECCFromDERPriv(g_keyData[key].buffer, g_keyData[key].buffer_len);
		if (ec == NULL) {
			SEC_LOG_ERROR("SecUtils_ECCFromDERPriv failed");
		}
	}

	return ec;
}

EVP_PKEY *TestCreds::asOpenSslEvpPkey(TestKey key) {
	EVP_PKEY *evp_key = NULL;

	if (SecKey_IsEcc(g_keyData[key].type)) {
		EC_KEY *ec = TestCreds::asOpenSslEcKey(key);
		if (ec == NULL) {
			SEC_LOG_ERROR("TestCreds::asOpenSslEcKey failed");
			return NULL;
		}

		evp_key = EVP_PKEY_new();
		if (evp_key == NULL) {
			SEC_LOG_ERROR("EVP_PKEY_new failed");
			return NULL;
		}

		if (0 == EVP_PKEY_set1_EC_KEY(evp_key, ec))
		{
			SEC_EVPPKEY_FREE(evp_key);
			SEC_ECC_FREE(ec);
			SEC_LOG_ERROR("EVP_PKEY_set1_EC failed");
			return NULL;
		}
	} else if (SecKey_IsRsa(g_keyData[key].type)) {
		RSA *rsa = TestCreds::asOpenSslRsa(key);
		if (rsa == NULL) {
			SEC_LOG_ERROR("TestCreds::asOpenSslRsa failed");
			return NULL;
		}

		evp_key = EVP_PKEY_new();
		if (evp_key == NULL) {
			SEC_LOG_ERROR("EVP_PKEY_new failed");
			return NULL;
		}

		if (0 == EVP_PKEY_set1_RSA(evp_key, rsa))
		{
			SEC_EVPPKEY_FREE(evp_key);
			SEC_RSA_FREE(rsa);
			SEC_LOG_ERROR("EVP_PKEY_set1_RSA failed");
			return NULL;
		}
	} else {
		SEC_LOG_ERROR("Not an asymetric key type");
		return NULL;
	}

    return evp_key;
}

static bool _Is_Valid_Point(EC_KEY* ec_key, const std::vector<SEC_BYTE> data)
{
    if (data.size() != SEC_ECC_NISTP256_KEY_LEN) {
        SEC_LOG_ERROR("Input size needed != One BIGNUM");
        return false;
    }

    // Convert the input buffer to be encrypted to a BIGNUM
    std::shared_ptr<BIGNUM> inputAsBN(BN_new(), BN_free);
    if (inputAsBN.get() == NULL) {
        SEC_LOG_ERROR("BN_new failed");
        return false;
    }

    if (BN_bin2bn(&data[0], data.size(), inputAsBN.get()) == NULL) {
        SEC_LOG_ERROR("BN_bin2bn failed. Error: %s", ERR_error_string(ERR_get_error(), NULL));
        return false;
    }

    const EC_GROUP *group = EC_KEY_get0_group(ec_key);
    if (NULL == group) {
        SEC_LOG_ERROR("EC_KEY_get0_group failed");
        return false;
    }

    std::shared_ptr<BN_CTX> ctx(BN_CTX_new(), BN_CTX_free);
    if (ctx.get() == NULL) {
        SEC_LOG_ERROR("BN_CTX_new failed");
        return false;
    }

    std::shared_ptr<EC_POINT> pt(EC_POINT_new(group), EC_POINT_free);
    if (pt.get() == NULL) {
        SEC_LOG_ERROR("EC_POINT_new failed");
        return false;
    }

    if (!EC_POINT_set_compressed_coordinates_GFp(group, pt.get(), inputAsBN.get(), 0, ctx.get())) {
        SEC_LOG_ERROR("EC_POINT_set_compressed_coordinates_GFp failed");
        return false;
    }

    return true;
}

static int _ElGamal_Encrypt_Rand(EC_KEY *ec_key,
                                  SEC_BYTE* input, SEC_SIZE inputSize,
                                  SEC_BYTE* output, SEC_SIZE outputSize,
                                  BIGNUM *sender_rand)
{
    int res = -1;
    BIGNUM *inputAsBN = NULL;
    const EC_GROUP *group = NULL;
    const EC_POINT *P = NULL;
    const EC_POINT *PK_recipient = NULL;
    EC_POINT *shared_secret = NULL;
    EC_POINT *key_2_wrap_point = NULL;
    EC_POINT *sender_share = NULL;
    EC_POINT *wrapped_key = NULL;
    BIGNUM *x = NULL;
    BIGNUM *y = NULL;
    BN_CTX *ctx = NULL;

    if (inputSize != SEC_ECC_NISTP256_KEY_LEN)
    {
        SEC_LOG_ERROR("Input size needed != One BIGNUM");
        goto done;
    }

    if (outputSize < 4 * SEC_ECC_NISTP256_KEY_LEN)
    {
        SEC_LOG_ERROR("Output size needed < Four BIGNUMs");
        goto done;
    }

    // Convert the input buffer to be encrypted to a BIGNUM
    inputAsBN = BN_new();
    if (inputAsBN == NULL)
    {
        SEC_LOG_ERROR("BN_new failed");
        goto done;
    }
    if (BN_bin2bn(input, inputSize, inputAsBN) == NULL)
    {
        SEC_LOG_ERROR("BN_bin2bn failed. Error: %s",
                      ERR_error_string(ERR_get_error(), NULL));
        goto done;
    }

    group = EC_KEY_get0_group(ec_key);
    if (NULL == group)
    {
        SEC_LOG_ERROR("EC_KEY_get0_group failed");
        goto done;
    }

    ctx = BN_CTX_new();
    if (ctx == NULL)
    {
        SEC_LOG_ERROR("BN_CTX_new failed");
        goto done;
    }

    // Convert the X coordinate to an EC Point.  This takes the desired Y value in 1 bit (to choose
    // which of the two possible Y values to use).  This *calculates* an actual Y value for the point.
    key_2_wrap_point = EC_POINT_new(group);
    if (key_2_wrap_point == NULL)
    {
        SEC_LOG_ERROR("EC_POINT_new failed");
        goto done;
    }

    if (!EC_POINT_set_compressed_coordinates_GFp(group, key_2_wrap_point, inputAsBN, 0, ctx)) //$$$ 1=>0 on 7/8/15
    {
        // Don't print an error message if the error is "point not on curve" 100A906E, but still fail
        if (ERR_get_error() != 0x100A906E) // i.e. error:100A906E:lib(16):func(169):reason(110)
        {
            SEC_LOG_ERROR("Set EC_POINT_set_compressed_coordinates_GFp failed. Error: %s",
                          ERR_error_string(ERR_get_error(), NULL));
        }
        goto done;
    }

    // Calc sender's shared point 'wP' => this gets sent back to receiver
    sender_share = EC_POINT_new(group);
    if (sender_share == NULL)
    {
        SEC_LOG_ERROR("EC_POINT_new failed");
        goto done;
    }

    P = EC_GROUP_get0_generator(group);
    if (P == NULL)
    {
        SEC_LOG_ERROR("EC_GROUP_get0_generator failed");
        goto done;
    }
    EC_POINT_mul(group, sender_share, NULL, P, sender_rand, ctx);

    // Calc sender's Shared Secret 'wRr'  => this hides the key I want to send
    shared_secret = EC_POINT_new(group);
    if (shared_secret == NULL)
    {
        SEC_LOG_ERROR("EC_POINT_new failed");
        goto done;
    }

    PK_recipient = EC_KEY_get0_public_key(ec_key);
    if (PK_recipient == NULL)
    {
        SEC_LOG_ERROR("EC_KEY_get0_public_key failed");
        goto done;
    }
    EC_POINT_mul(group, shared_secret, NULL, PK_recipient, sender_rand, ctx);

    // key_2_wrap_point is a point on the curve, we add the shared_secret
    // to it and send the result, the wrapped_key, to the receiver.
    wrapped_key = EC_POINT_new(group);
    if (wrapped_key == NULL)
    {
        SEC_LOG_ERROR("EC_POINT_new failed");
        goto done;
    }
    EC_POINT_add(group, wrapped_key, key_2_wrap_point, shared_secret, ctx);

    // Dissect the wrapped point to get its coordinates
    x = BN_new();
    if (x == NULL)
    {
        SEC_LOG_ERROR("BN_new failed");
        goto done;
    }
    y = BN_new();
    if (y == NULL)
    {
        SEC_LOG_ERROR("BN_new failed");
        goto done;
    }

    // Dissect shared_secret to get its coordinates and output them
    EC_POINT_get_affine_coordinates_GFp(group, sender_share, x, y, ctx);

    if (SEC_RESULT_SUCCESS != _BigNumToBuffer(x, (unsigned char *) &output[0 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN)) {
        SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
        goto done;
    }

    if (SEC_RESULT_SUCCESS != _BigNumToBuffer(y, (unsigned char *) &output[1 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN)) {
        SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
        goto done;
    }

    // Dissect wrapped_key to get its coordinates and output them
    EC_POINT_get_affine_coordinates_GFp(group, wrapped_key, x, y, ctx);

    if (SEC_RESULT_SUCCESS != _BigNumToBuffer(x, (unsigned char *) &output[2 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN)) {
        SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
        goto done;
    }

    if (SEC_RESULT_SUCCESS != _BigNumToBuffer(y, (unsigned char *) &output[3 * SEC_ECC_NISTP256_KEY_LEN], SEC_ECC_NISTP256_KEY_LEN)) {
        SEC_LOG_ERROR("SecUtils_BigNumToBuffer failed");
        goto done;
    }

    res = 4 * SEC_ECC_NISTP256_KEY_LEN;

done:
    if (NULL != x)
        BN_free(x);
    if (NULL != y)
        BN_free(y);
    if (NULL != inputAsBN)
        BN_free(inputAsBN);
    if (NULL != sender_rand)
        BN_free(sender_rand);
    if (NULL != shared_secret)
        EC_POINT_free(shared_secret);
    if (NULL != sender_share)
        EC_POINT_free(sender_share);
    if (NULL != key_2_wrap_point)
        EC_POINT_free(key_2_wrap_point);
    if (NULL != wrapped_key)
        EC_POINT_free(wrapped_key);
    BN_CTX_free(ctx);

    return res;
}

static int _ElGamal_Encrypt(EC_KEY *ec_key,
                             SEC_BYTE* input, SEC_SIZE inputSize,
                             SEC_BYTE* output, SEC_SIZE outputSize)
{
    // Generate random number 'w' (multiplier) for the sender
    BIGNUM *sender_rand = BN_new();

    if (sender_rand == NULL)
    {
        SEC_LOG_ERROR("BN_new failed");
        return -1;
    }
    if (0 == BN_rand(sender_rand, 256, -1, 0))
    {
        SEC_LOG_ERROR("BN_rand failed");
        if (NULL != sender_rand)
            BN_free(sender_rand);
        return -1;
    }

    return _ElGamal_Encrypt_Rand(ec_key,
                                         input, inputSize,
                                         output, outputSize,
                                         sender_rand);
}

static std::vector<SEC_BYTE> opensslRsaCrypt(RSA *rsa, Sec_CipherAlgorithm algorithm, Sec_CipherMode mode, const std::vector<SEC_BYTE>& input) {
    int padding;
    if (algorithm == SEC_CIPHERALGORITHM_RSA_PKCS1_PADDING) {
        padding = RSA_PKCS1_PADDING;
    } else {
        padding = RSA_PKCS1_OAEP_PADDING;
    }

    int openssl_res;
    std::vector<SEC_BYTE> output;
    output.resize(RSA_size(rsa));

    if (mode == SEC_CIPHERMODE_ENCRYPT || mode == SEC_CIPHERMODE_ENCRYPT_NATIVEMEM) {
        openssl_res = RSA_public_encrypt(input.size(), &input[0], &output[0], rsa, padding);
    } else {
        openssl_res = RSA_private_decrypt(input.size(), &input[0], &output[0], rsa, padding);
    }

    if (openssl_res < 0)
    {
        SEC_LOG_ERROR("%s", ERR_error_string(ERR_get_error(), NULL));
        return std::vector<SEC_BYTE>();
    }

    output.resize(openssl_res);

    return output;
}

static Sec_Result _RSAToDERPrivKeyInfo(RSA *rsa, SEC_BYTE *output, SEC_SIZE out_len, SEC_SIZE *written)
{
    BIO *bio = NULL;
    EVP_PKEY *evp_key = NULL;
    BUF_MEM *bptr = NULL;
    Sec_Result res = SEC_RESULT_FAILURE;

    evp_key = EVP_PKEY_new();
    if (0 == EVP_PKEY_set1_RSA(evp_key, rsa))
    {
        SEC_LOG_ERROR("EVP_PKEY_set1_RSA failed");
        goto done;
    }

    bio = BIO_new(BIO_s_mem());
    if (bio == NULL)
    {
        SEC_LOG_ERROR("BIO_new(BIO_s_mem()) failed");
        goto done;
    }

    if (!i2d_PKCS8PrivateKeyInfo_bio(bio, evp_key))
    {
        SEC_LOG_ERROR("i2d_PKCS8_PRIV_KEY_INFO_bio failed");
        goto done;
    }

    BIO_flush(bio);
    BIO_get_mem_ptr(bio, &bptr);

    *written = bptr->length;

    if (output != NULL)
    {
        if (out_len < bptr->length)
        {
            SEC_LOG_ERROR("output buffer is not large enough");
            goto done;
        }
        memcpy(output, bptr->data, bptr->length);
    }

    res = SEC_RESULT_SUCCESS;

done:
    SEC_EVPPKEY_FREE(evp_key);
    SEC_BIO_FREE(bio);

    return res;
}

static std::vector<SEC_BYTE> toPkcs8(RSA* rsa) {
    std::vector<SEC_BYTE> pkcs8;
    pkcs8.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE pkcs8_len;

    if (SEC_RESULT_SUCCESS != _RSAToDERPrivKeyInfo(rsa, &pkcs8[0], pkcs8.size(), &pkcs8_len)) {
        SEC_LOG_ERROR("SecUtils_RSAToDERPriv failed");
        return std::vector<SEC_BYTE>();
    }

    pkcs8.resize(pkcs8_len);

    return pkcs8;
}

template <typename T> std::vector<T> concat(std::vector<T> &a, std::vector<T> &b) {
    std::vector<T> ret = std::vector<T>();
    std::copy(a.begin(), a.end(), std::back_inserter(ret));
    std::copy(b.begin(), b.end(), std::back_inserter(ret));
    return ret;
}

ProvKey* TestCreds::wrapAesWithEc(const SEC_BYTE* clear, Sec_KeyType type, EC_KEY *ec_key, SEC_OBJECTID wrappingId, Sec_CipherAlgorithm asymAlg) {
    std::vector<SEC_BYTE> payload;
    payload.resize(32);

    if (type == SEC_KEYTYPE_AES_128) {
        memcpy(&payload[0], clear, 16);
        memcpy(&payload[16], clear, 16);
    } else {
        memcpy(&payload[0], clear, 32);
    }

    std::vector<SEC_BYTE> encrypted;
    encrypted.resize(SEC_ECC_NISTP256_KEY_LEN*4);

    int encrypted_len = _ElGamal_Encrypt(ec_key,
                             &payload[0], payload.size(),
                             &encrypted[0], encrypted.size());

    if (encrypted_len <= 0) {
        SEC_LOG_ERROR("_ElGamal_Encrypt failed");
        return NULL;
    }

    encrypted.resize(encrypted_len);

    std::vector<SEC_BYTE> res;
    res.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE res_len;
    if (SEC_RESULT_SUCCESS != SecKey_GenerateWrappedKeyAsn1Off(&encrypted[0], encrypted.size(),
            type, wrappingId, NULL, asymAlg,
            &res[0], res.size(), &res_len, 32 - SecKey_GetKeyLenForKeyType(type))) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return NULL;
    }
    res.resize(res_len);

    return new ProvKey(res, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapAesWithRsa(const SEC_BYTE* data, Sec_KeyType type, RSA *rsa_key, SEC_OBJECTID wrappingId, Sec_CipherAlgorithm asymAlg) {
    std::vector<SEC_BYTE> clear(data, data+SecKey_GetKeyLenForKeyType(type));
    std::vector<SEC_BYTE> wrapped = opensslRsaCrypt(rsa_key, asymAlg, SEC_CIPHERMODE_ENCRYPT, clear);

    if (wrapped.size() == 0) {
        SEC_LOG_ERROR("opensslRsaCrypt failed");
        return NULL;
    }

    std::vector<SEC_BYTE> res;
    res.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE res_len;

    if (SEC_RESULT_SUCCESS != SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type, wrappingId, NULL, asymAlg, &res[0], res.size(), &res_len)) {
        SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
        return NULL;
    }

    return new ProvKey(res, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapAesWithAes(const SEC_BYTE* clear, Sec_KeyType type, const SEC_BYTE* wrapping, Sec_KeyType wrappingType, SEC_OBJECTID wrappingId, Sec_CipherAlgorithm symAlg) {
    std::vector<SEC_BYTE> iv = TestCtx::random(SEC_AES_BLOCK_SIZE);

    TestCtx ctx;
    ctx.init();

    if (NULL == ctx.provisionKey(wrappingId, SEC_STORAGELOC_RAM, wrapping, SecKey_GetKeyLenForKeyType(wrappingType),
        wrappingType == SEC_KEYTYPE_AES_128 ? SEC_KEYCONTAINER_RAW_AES_128 : SEC_KEYCONTAINER_RAW_AES_256)) {
        SEC_LOG_ERROR("TestCtx::provisionKey failed");
        return NULL;
    }

    std::vector<SEC_BYTE> wrapped;
    wrapped.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE wrapped_len;
    if (SEC_RESULT_SUCCESS != SecUtils_WrapSymetric(ctx.proc(), wrappingId,
        symAlg, &iv[0],
        (SEC_BYTE*) clear, SecKey_GetKeyLenForKeyType(type),
        &wrapped[0], wrapped.size(), &wrapped_len)) {
      SEC_LOG_ERROR("SecUtils_WrapSymetric failed");
      return NULL;
    }
    wrapped.resize(wrapped_len);

    std::vector<SEC_BYTE> asn1;
    asn1.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE asn1_len;

    if (SEC_RESULT_SUCCESS != SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type,
        wrappingId, &iv[0], symAlg,
        &asn1[0], asn1.size(), &asn1_len)) {
      SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
      return NULL;
    }
    asn1.resize(asn1_len);

    return new ProvKey(asn1, SEC_KEYCONTAINER_ASN1);
}

ProvKey* TestCreds::wrapRsaWithAes(RSA* rsa, const SEC_BYTE* wrapping, Sec_KeyType wrappingType, SEC_OBJECTID wrappingId, Sec_CipherAlgorithm symAlg) {
    std::vector<SEC_BYTE> iv = TestCtx::random(SEC_AES_BLOCK_SIZE);

    TestCtx ctx;
    ctx.init();

    if (NULL == ctx.provisionKey(wrappingId, SEC_STORAGELOC_RAM, wrapping, SecKey_GetKeyLenForKeyType(wrappingType),
        wrappingType == SEC_KEYTYPE_AES_128 ? SEC_KEYCONTAINER_RAW_AES_128 : SEC_KEYCONTAINER_RAW_AES_256)) {
        SEC_LOG_ERROR("TestCtx::provisionKey failed");
        return NULL;
    }

    std::vector<SEC_BYTE> pkcs8 = toPkcs8(rsa);
    if (pkcs8.size() == 0) {
        SEC_LOG_ERROR("toPkcs8 failed");
        return NULL;
    }
    Sec_KeyType type = (RSA_size(rsa) == 128) ? SEC_KEYTYPE_RSA_1024 : SEC_KEYTYPE_RSA_2048;

    std::vector<SEC_BYTE> wrapped;
    wrapped.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE wrapped_len;
    if (SEC_RESULT_SUCCESS != SecUtils_WrapSymetric(ctx.proc(), wrappingId,
        symAlg, &iv[0],
        &pkcs8[0], pkcs8.size(),
        &wrapped[0], wrapped.size(), &wrapped_len)) {
      SEC_LOG_ERROR("SecUtils_WrapSymetric failed");
      return NULL;
    }
    wrapped.resize(wrapped_len);

    std::vector<SEC_BYTE> asn1;
    asn1.resize(SEC_KEYCONTAINER_MAX_LEN);
    SEC_SIZE asn1_len;

    if (SEC_RESULT_SUCCESS != SecKey_GenerateWrappedKeyAsn1(&wrapped[0], wrapped.size(), type,
        wrappingId, &iv[0], symAlg,
        &asn1[0], asn1.size(), &asn1_len)) {
      SEC_LOG_ERROR("SecKey_GenerateWrappedKeyAsn1 failed");
      return NULL;
    }
    asn1.resize(asn1_len);

    return new ProvKey(asn1, SEC_KEYCONTAINER_ASN1);
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainEcAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id, Sec_CipherAlgorithm asymAlg) {
  std::vector<ProvKey> res;

  //generate key0
  std::shared_ptr<ProvKey> provKey(TestCreds::getKey(TESTKEY_EC_PRIV, kc, base_id));
  res.push_back(*provKey);

  //generate key1
  std::shared_ptr<EC_KEY> ec_key(TestCreds::asOpenSslEcKey(TESTKEY_EC_PRIV), EC_KEY_free);
  std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithEc(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), ec_key.get(), base_id, asymAlg));
  res.push_back(*wrappedKey1);

  return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainEcAesAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id, Sec_KeyType aesType, Sec_CipherAlgorithm asymAlg, Sec_CipherAlgorithm symAlg) {
  std::vector<ProvKey> res;

  //generate key0
  std::shared_ptr<ProvKey> provKey(TestCreds::getKey(TESTKEY_EC_PRIV, kc, base_id));

  res.push_back(*provKey);

  //generate key1
  std::shared_ptr<EC_KEY> ec_key(TestCreds::asOpenSslEcKey(TESTKEY_EC_PRIV), EC_KEY_free);
  std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
  while (!_Is_Valid_Point(ec_key.get(), (SecKey_GetKeyLenForKeyType(aesType) == 16) ? concat(key1, key1) : key1)) {
      SEC_PRINT("Not a valid point.  Regenerating.\n");
      key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
  }

  std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithEc(&key1[0], aesType, ec_key.get(), base_id, asymAlg));
  res.push_back(*wrappedKey1);

  //generate key2
  std::shared_ptr<ProvKey> wrappedKey2(wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key1[0], aesType, base_id+1, symAlg));
  res.push_back(*wrappedKey2);

  return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAesRsaAesAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id, Sec_KeyType rsaType, Sec_CipherAlgorithm asymAlg, Sec_KeyType aesType, Sec_CipherAlgorithm symAlg, Sec_CipherAlgorithm ckSymAlg) {
  std::vector<ProvKey> res;

  //generate key0
  TestKey rsaPrivKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
  std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaPrivKey, kc, base_id));
  res.push_back(*provKey);

  //generate key1
  std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
  std::shared_ptr<RSA> rsa_key(TestCreds::asOpenSslRsa(rsaPrivKey), RSA_free);
  std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithRsa(&key1[0], aesType, rsa_key.get(), base_id, asymAlg));
  res.push_back(*wrappedKey1);

  //generate key2
  std::shared_ptr<ProvKey> wrappedKey2(wrapRsaWithAes(rsa_key.get(), &key1[0], aesType, base_id+1, symAlg));
  res.push_back(*wrappedKey2);

  //generate key3
  std::vector<SEC_BYTE> key3 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));
  std::shared_ptr<ProvKey> wrappedKey3(wrapAesWithRsa(&key3[0], aesType, rsa_key.get(), base_id+2, asymAlg));
  res.push_back(*wrappedKey3);

  //generate key4
  std::shared_ptr<ProvKey> wrappedKey4(wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key3[0], aesType, base_id+3, ckSymAlg));
  res.push_back(*wrappedKey4);

  return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id, Sec_KeyType rsaType, Sec_CipherAlgorithm asymAlg) {
  std::vector<ProvKey> res;

  //generate key0
  TestKey rsaKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
  std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaKey, kc, base_id));
  res.push_back(*provKey);

  //generate key1
  std::shared_ptr<RSA> rsa(TestCreds::asOpenSslRsa(rsaKey), RSA_free);
  std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithRsa(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), rsa.get(), base_id, asymAlg));
  res.push_back(*wrappedKey1);

  return res;
}

std::vector<ProvKey> TestCreds::getWrappedContentKeyChainRsaAesAes(TestKey contentKey, TestKc kc, SEC_OBJECTID base_id, Sec_KeyType rsaType, Sec_CipherAlgorithm asymAlg, Sec_KeyType aesType, Sec_CipherAlgorithm symAlg) {
  std::vector<ProvKey> res;

  //generate key0
  TestKey rsaPrivKey = (rsaType == SEC_KEYTYPE_RSA_1024) ? TESTKEY_RSA1024_KEK_PRIV : TESTKEY_RSA2048_KEK_PRIV;
  std::shared_ptr<ProvKey> provKey(TestCreds::getKey(rsaPrivKey, kc, base_id));
  res.push_back(*provKey);

  //generate key1
  std::vector<SEC_BYTE> key1 = TestCtx::random(SecKey_GetKeyLenForKeyType(aesType));

  std::shared_ptr<RSA> rsa_key(TestCreds::asOpenSslRsa(rsaPrivKey), RSA_free);
  std::shared_ptr<ProvKey> wrappedKey1(wrapAesWithRsa(&key1[0], aesType, rsa_key.get(), base_id, asymAlg));
  res.push_back(*wrappedKey1);

  //generate key2
  std::shared_ptr<ProvKey> wrappedKey2(wrapAesWithAes(TestCreds::asOpenSslAes(contentKey).data(), TestCreds::getKeyType(contentKey), &key1[0], aesType, base_id+1, symAlg));
  res.push_back(*wrappedKey2);

  return res;
}
